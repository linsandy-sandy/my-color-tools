<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF è½‰ PPT (ä¸­æ–‡ OCR ä¿®å¾©ç‰ˆ v24)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PPT ç”Ÿæˆåº« -->
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
    <!-- PDF è§£æåº« -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <!-- OCR å¼•æ“ (Tesseract v5) -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.3/dist/tesseract.min.js"></script>
    
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans TC', sans-serif; background-color: #f3f4f6; }
        
        .drop-zone {
            transition: all 0.3s ease;
        }
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }

        .slide-preview {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s;
        }
        .slide-preview:hover {
            transform: translateY(-2px);
        }
        
        /* Toggle Switch */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #68D391;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #68D391;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col text-slate-800">

    <!-- Header -->
    <header class="bg-white border-b border-slate-200 sticky top-0 z-50">
        <div class="max-w-5xl mx-auto px-6 py-4 flex justify-between items-center">
            
            <div class="flex items-center gap-4">
                <!-- Home Button -->
                <a href="index.html" class="flex items-center justify-center w-10 h-10 rounded-full bg-slate-100 text-slate-500 hover:bg-blue-50 hover:text-blue-600 transition-colors shadow-sm" title="å›é¦–é ">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z" />
                    </svg>
                </a>
                
                <div class="h-6 w-px bg-slate-300"></div>

                <div class="flex items-center gap-2">
                    <span class="text-2xl">ğŸ“Š</span>
                    <h1 class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-600 to-indigo-600">
                        PDF è½‰ PPT <span class="text-xs text-slate-500 font-normal ml-2 border border-slate-200 rounded px-2 py-0.5">OCR ä¿®å¾©ç‰ˆ</span>
                    </h1>
                </div>
            </div>

            <button id="btn-convert" onclick="generatePPT()" disabled 
                class="bg-slate-200 text-slate-400 font-bold py-2 px-6 rounded-lg transition-all cursor-not-allowed flex items-center gap-2">
                <span>â¬‡ï¸</span> ä¸‹è¼‰ PPT
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow max-w-5xl mx-auto w-full px-6 py-8">
        
        <!-- Upload Area -->
        <div class="mb-8 space-y-4">
            <label class="drop-zone block w-full border-3 border-dashed border-slate-300 rounded-xl p-10 text-center cursor-pointer bg-white">
                <input type="file" id="fileInput" accept="application/pdf" class="hidden" onchange="handleFile(this)">
                <div class="text-5xl mb-4">ğŸ“‚</div>
                <h3 class="text-lg font-bold text-slate-700">æ­¥é©Ÿ 1: ä¸Šå‚³ PDF ç°¡å ±</h3>
                <p class="text-slate-500 mt-2 text-sm">æ”¯æ´åœ–ç‰‡å‹ PDFï¼Œè½‰ç‚ºé«˜ç•«è³ªæŠ•å½±ç‰‡</p>
            </label>

            <!-- Settings -->
            <div class="bg-white rounded-xl p-6 border border-slate-200 shadow-sm">
                <div class="flex flex-col md:flex-row justify-between items-center gap-4">
                    <div class="flex items-center gap-3">
                        <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" name="toggle" id="ocr-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                            <label for="ocr-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                        </div>
                        <div>
                            <label for="ocr-toggle" class="font-bold text-slate-700 cursor-pointer">å•Ÿç”¨å‚™å¿˜éŒ„ OCR (AI è¾¨è­˜)</label>
                            <p class="text-xs text-slate-500">è‹¥ PDF æ˜¯åœ–ç‰‡ï¼Œè«‹é–‹å•Ÿæ­¤é …ä»¥æå–æ–‡å­—è‡³å‚™å¿˜éŒ„ã€‚</p>
                        </div>
                    </div>
                    
                    <!-- OCR Status Indicator -->
                    <div id="ocr-status-badge" class="hidden px-3 py-1 bg-orange-100 text-orange-700 text-xs rounded-full flex items-center gap-2">
                        <div class="animate-spin h-3 w-3 border-2 border-orange-500 border-t-transparent rounded-full"></div>
                        <span>ç­‰å¾…ä¸‹è¼‰ä¸­æ–‡æ¨¡å‹...</span>
                    </div>
                </div>
                
                <p class="mt-4 text-xs text-slate-400 border-t pt-3">
                    ğŸ’¡ æç¤ºï¼šæ­¤é¸é …åƒ…å½±éŸ¿ PowerPoint ä¸‹æ–¹çš„ã€Œå‚™å¿˜éŒ„ã€ã€‚æŠ•å½±ç‰‡æœ¬èº«å°‡ä¿æŒ 100% åŸåœ–ç•«è³ªã€‚
                </p>
            </div>
        </div>

        <!-- Processing Status -->
        <div id="status-area" class="hidden mb-8 bg-blue-50 border border-blue-100 rounded-lg p-4 flex flex-col gap-2">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="animate-spin h-5 w-5 border-2 border-blue-600 border-t-transparent rounded-full"></div>
                    <span id="status-text" class="text-blue-700 font-medium">æ­£åœ¨æº–å‚™...</span>
                </div>
                <span id="progress-percent" class="text-blue-600 font-bold">0%</span>
            </div>
            <div class="w-full bg-blue-200 rounded-full h-2">
                <div id="progress-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
        </div>

        <!-- Preview Grid -->
        <div id="preview-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <!-- Previews will be injected here -->
        </div>

    </main>

    <!-- Invisible Canvas -->
    <canvas id="render-canvas" class="hidden"></canvas>

    <script>
        let pdfDoc = null;
        let pdfFileName = "presentation";
        let worker = null;
        let isOcrReady = false;

        // UI Event Listeners
        document.getElementById('ocr-toggle').addEventListener('change', async function(e) {
            const badge = document.getElementById('ocr-status-badge');
            const btn = document.getElementById('btn-convert');
            
            if (e.target.checked) {
                badge.classList.remove('hidden');
                btn.disabled = true; // Lock button until loaded
                btn.classList.add('cursor-not-allowed', 'opacity-50');
                
                // Start loading immediately
                await initOCR();
                
                badge.className = "px-3 py-1 bg-green-100 text-green-700 text-xs rounded-full flex items-center gap-2";
                badge.innerHTML = "<span>âœ… ä¸­æ–‡æ¨¡å‹å°±ç·’</span>";
                btn.disabled = false;
                btn.classList.remove('cursor-not-allowed', 'opacity-50');
            } else {
                badge.classList.add('hidden');
                // Even if OCR is off, enable button if PDF is loaded
                if (pdfDoc) {
                    btn.disabled = false;
                    btn.classList.remove('cursor-not-allowed', 'opacity-50');
                }
            }
        });

        async function initOCR() {
            if (worker) return; // Already loaded
            
            try {
                // Initialize worker with explicit combined language
                // Note: 'chi_tra+eng' ensures it looks for both Chinese Traditional and English
                worker = await Tesseract.createWorker('chi_tra+eng', 1, {
                    logger: m => {
                        // Optional: Log progress to console
                        if (m.status === 'loading tesseract core') console.log("è¼‰å…¥æ ¸å¿ƒ...");
                    }
                });
                
                isOcrReady = true;
            } catch (e) {
                console.error("OCR Load Error:", e);
                alert("ä¸­æ–‡æ¨¡å‹ä¸‹è¼‰å¤±æ•— (ç¶²è·¯å•é¡Œ)ã€‚\nè«‹å˜—è©¦é—œé–‰å†é‡æ–°é–‹å•Ÿ OCR é¸é …ï¼Œæˆ–é‡æ–°æ•´ç†é é¢ã€‚");
                // Reset toggle
                document.getElementById('ocr-toggle').checked = false;
                document.getElementById('ocr-status-badge').classList.add('hidden');
            }
        }

        // 1. è™•ç†æª”æ¡ˆä¸Šå‚³
        function handleFile(input) {
            const file = input.files[0];
            if (!file) return;
            
            pdfFileName = file.name.replace('.pdf', '');
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                const typedarray = new Uint8Array(e.target.result);
                try {
                    document.getElementById('status-area').classList.remove('hidden');
                    updateStatus("æ­£åœ¨åˆ†æ PDF çµæ§‹...", 10);
                    
                    pdfDoc = await pdfjsLib.getDocument(typedarray).promise;
                    
                    updateStatus(`è®€å–æˆåŠŸï¼å…± ${pdfDoc.numPages} é `, 100);
                    
                    // å•Ÿç”¨ä¸‹è¼‰æŒ‰éˆ• (é™¤é OCR æ­£åœ¨åŠ è¼‰ä¸­)
                    const btn = document.getElementById('btn-convert');
                    const ocrLoading = document.getElementById('ocr-toggle').checked && !isOcrReady;
                    
                    if (!ocrLoading) {
                        btn.disabled = false;
                        btn.classList.remove('bg-slate-200', 'text-slate-400', 'cursor-not-allowed');
                        btn.classList.add('bg-blue-600', 'hover:bg-blue-700', 'text-white', 'shadow-lg');
                    }
                    
                    // ç”¢ç”Ÿç¸®åœ–é è¦½
                    renderPreviews();

                } catch (err) {
                    console.error(err);
                    alert("PDF è®€å–å¤±æ•—ã€‚è«‹ç¢ºèªæª”æ¡ˆæ˜¯å¦ç‚º PDF æ ¼å¼ã€‚");
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function updateStatus(text, percent) {
            document.getElementById('status-text').innerText = text;
            if (percent !== undefined) {
                document.getElementById('progress-bar').style.width = `${percent}%`;
                document.getElementById('progress-percent').innerText = `${Math.round(percent)}%`;
            }
        }

        // 2. æ¸²æŸ“é è¦½åœ–
        async function renderPreviews() {
            const grid = document.getElementById('preview-grid');
            grid.innerHTML = '';
            
            const maxPreview = Math.min(pdfDoc.numPages, 6);
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            for(let i=1; i<=maxPreview; i++) {
                const page = await pdfDoc.getPage(i);
                const viewport = page.getViewport({ scale: 0.5 });
                
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                
                await page.render({ canvasContext: ctx, viewport: viewport }).promise;
                
                const card = document.createElement('div');
                card.className = "bg-white p-3 rounded-lg slide-preview";
                card.innerHTML = `
                    <div class="aspect-video bg-slate-100 rounded overflow-hidden mb-3 border border-slate-200">
                        <img src="${canvas.toDataURL()}" class="w-full h-full object-contain">
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-xs font-bold text-slate-500">ç¬¬ ${i} é </span>
                    </div>
                `;
                grid.appendChild(card);
            }
        }

        // 3. æ ¸å¿ƒåŠŸèƒ½ï¼šç”Ÿæˆ PPT
        async function generatePPT() {
            if (!pdfDoc) return;
            
            const btn = document.getElementById('btn-convert');
            const useOCR = document.getElementById('ocr-toggle').checked;
            const originalText = btn.innerHTML;
            
            btn.disabled = true;
            btn.innerHTML = `<span class="animate-spin">â³</span> è™•ç†ä¸­...`;
            
            const pptx = new PptxGenJS();
            pptx.layout = 'LAYOUT_16x9';
            
            const canvas = document.getElementById('render-canvas');
            const ctx = canvas.getContext('2d');

            try {
                for (let i = 1; i <= pdfDoc.numPages; i++) {
                    const progress = (i / pdfDoc.numPages) * 100;
                    updateStatus(`æ­£åœ¨è™•ç†ç¬¬ ${i} / ${pdfDoc.numPages} é ...`, progress);
                    
                    const page = await pdfDoc.getPage(i);
                    // ä½¿ç”¨ 2.0 å€ç¸®æ”¾ä»¥ç¢ºä¿ PPT èƒŒæ™¯æ¸…æ™°
                    const viewport = page.getViewport({ scale: 2.0 }); 
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    
                    await page.render({ canvasContext: ctx, viewport: viewport }).promise;
                    const imgData = canvas.toDataURL('image/jpeg', 0.8);
                    
                    // --- æ–‡å­—æå–é‚è¼¯ (AI å¢å¼·) ---
                    let noteText = "";
                    
                    // 1. å˜—è©¦è®€å– PDF åŸç”Ÿæ–‡å­— (æœ€å¿«ã€æœ€æº–)
                    try {
                        const textContent = await page.getTextContent();
                        const rawText = textContent.items.map(item => item.str).join(" ");
                        if (rawText.trim().length > 10) {
                            noteText = rawText; 
                        }
                    } catch (e) {}

                    // 2. è‹¥ç„¡å­—ä¸”é–‹å•Ÿ OCR -> ä½¿ç”¨ Tesseract
                    if ((!noteText || noteText.trim().length === 0) && useOCR && worker) {
                        updateStatus(`ç¬¬ ${i} é ï¼šAI æ­£åœ¨é–±è®€æ–‡å­— (OCR)...`, progress);
                        
                        try {
                            const { data } = await worker.recognize(canvas);
                            // ç°¡å–®æ¸…ç†ï¼šç§»é™¤éçŸ­çš„é›œè¨Šè¡Œ
                            const cleanText = data.lines
                                .map(line => line.text.trim())
                                .filter(text => text.length > 1) // éæ¿¾å–®å­—å…ƒé›œè¨Š
                                .join('\n');
                                
                            noteText = cleanText;
                        } catch (ocrError) {
                            console.warn("OCR Error on page " + i, ocrError);
                            noteText = "(æœ¬é  OCR è¾¨è­˜å¤±æ•—)";
                        }
                    }

                    // å»ºç«‹ Slide
                    let slide = pptx.addSlide();
                    slide.background = { data: imgData };
                    
                    if (noteText && noteText.trim().length > 0) {
                        slide.addNotes(noteText);
                    }
                }

                updateStatus("æ‰“åŒ…ä¸‹è¼‰ä¸­...", 100);
                await pptx.writeFile({ fileName: `${pdfFileName}_converted.pptx` });
                
                updateStatus("è½‰æ›å®Œæˆï¼", 100);
                btn.innerHTML = originalText;
                btn.disabled = false;

            } catch (err) {
                console.error(err);
                alert("è½‰æ›éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤ã€‚è«‹æŸ¥çœ‹æ§åˆ¶å° (F12) ç²å–æ›´å¤šè³‡è¨Šã€‚");
                btn.disabled = false;
                btn.innerHTML = originalText;
            }
        }
    </script>
</body>
</html>